<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Sebastián Miró</title>
</head>

<style>

body {
	background: #121212;
    font: 17px/1.5 system-ui, sans-serif;
	color: #fff;
    margin: 10vh 10vw;
}

pre {
    padding: 1vmin;
    border-radius: 4px;
    background-color: #222222 !important;
}

code {
    border-radius: 4px;
    background-color: #222222 !important;
}

img {
    max-width: 66ch;
}

table {
    width: 100%;
}

a, a:visited {
    font-size: 17px;
    color: #F2F2F2;
    text-decoration: none;
    font-weight: bold;
}

a:hover,
#title:hover > a {
    color: #FF6913;
} 

#title:hover > span {
    visibility: visible !important;
}

</style>

<body>

<div style="max-width: 66ch;">
    


    <a href=https:&#x2F;&#x2F;sebamiro.github.io&#x2F;porfolio&#x2F; >Back</a>
    <p><a target="blank" href="https://github.com/sebamiro/get_next_line42/">GitHub</a></p>
<hr />
<h1 id="get-next-line">Get_next_line</h1>
<h2 id="summary">Summary</h2>
<p>Is an individual project about creating a function that returns the next line
from a file descriptor, without knowing its size beforehand.
One of the goal of this project is to learn a highly interesting
concept in C programming: static variables, and to gain a deeper understanding
of allocations, whether they happen on the stack memory or in the heap memory,
the manipulation and the life cycle of a buffer, the unexpected complexity implied
in the use of one or many static variables.
<br></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>char*
</span><span>get_next_line(int fd)
</span><span>{
</span><span>	static char	*staticbuf;
</span><span>	char		*line;
</span><span>
</span><span>	if (fd &lt; 0 || BUFFER_SIZE &lt;= 0 || read(fd, 0, 0) &lt; 0)
</span><span>		return (NULL);
</span><span>	staticbuf = ftread(fd, staticbuf);
</span><span>	if (!staticbuf)
</span><span>		return (NULL);
</span><span>	line = findline(staticbuf);
</span><span>	staticbuf = nextline(staticbuf);
</span><span>	return (line);
</span><span>}
</span></code></pre>
<h2 id="introduction">Introduction</h2>
<p>This project will not only allow you to add a very convenient function to your collection,
but it will also make you learn a highly interesting new concept in C programming: static
variables.</p>
<h2 id="mandatory-part">Mandatory part</h2>
<p>Write a function that returns a line read from a
file descriptor</p>
<ul>
<li>Repeated calls (e.g., using a loop) to your get_next_line() function should let
you read the text file pointed to by the file descriptor, one line at a time.</li>
<li>Your function should return the line that was read.
If there is nothing else to read or if an error occurred, it should return NULL.</li>
<li>Make sure that your function works as expected both when reading a file and when
reading from the standard input.</li>
<li>Please note that the returned line should include the terminating \n character,
except if the end of file was reached and does not end with a \n character.</li>
<li>Your header file get_next_line.h must at least contain the prototype of the
get_next_line() function.</li>
<li>Add all the helper functions you need in the get_next_line_utils.c file.</li>
<li>Because you will have to read files in get_next_line(), add this option to your
compiler call: -D BUFFER_SIZE=n
It will define the buffer size for read().
The buffer size value will be modified by your peer-evaluators and the Moulinette
in order to test your code.</li>
<li>You will compile your code as follows (a buffer size of 42 is used as an example):<br> 
<code>cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c</code></li>
<li>We consider that get_next_line() has an undefined behavior if the file pointed to
by the file descriptor changed since the last call whereas read() didn’t reach the
end of file.</li>
<li>We also consider that get_next_line() has an undefined behavior when reading
a binary file. However, you can implement a logical way to handle this behavior if
you want to.</li>
</ul>
<h3 id="frobbiden">Frobbiden</h3>
<ul>
<li>You are not allowed to use your libft in this project.</li>
<li>lseek() is forbidden.</li>
<li>Global variables are forbidden.</li>
</ul>
<h2 id="bonus-part">Bonus part</h2>
<p>This project is straightforward and doesn’t allow complex bonuses. However, we trust
your creativity. If you completed the mandatory part, give a try to this bonus part.</p>
<p>Here are the bonus part requirements:</p>
<ul>
<li>Develop get_next_line() using only one static variable.</li>
<li>Your get_next_line() can manage multiple file descriptors at the same time.
For example, if you can read from the file descriptors 3, 4 and 5, you should be
able to read from a different fd per call without losing the reading thread of each
file descriptor or returning a line from another fd.
It means that you should be able to call get_next_line() to read from fd 3, then
fd 4, then 5, then once again 3, once again 4, and so forth.</li>
</ul>




</div>

</body>

</html>
